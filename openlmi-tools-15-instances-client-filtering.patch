diff --git a/cli/lmi/shell/LMIBaseClient.py b/cli/lmi/shell/LMIBaseClient.py
index 6a0f677..2fc3f53 100644
--- a/cli/lmi/shell/LMIBaseClient.py
+++ b/cli/lmi/shell/LMIBaseClient.py
@@ -178,7 +178,8 @@ class LMIBaseClient(object):
 
     # NOTE: usage with Key=something, Value=something is deprecated
     # NOTE: inst_filter is either None or dict
-    def _get_instances(self, class_name, namespace=None, inst_filter=None, **kwargs):
+    def _get_instances(self, class_name, namespace=None, inst_filter=None,
+            client_filtering=False, **kwargs):
         """
         Returns a list of :py:class:`CIMInstance` objects.
 
@@ -187,6 +188,8 @@ class LMIBaseClient(object):
         :param dictionary inst_filter: dictionary containing filter values. The key
             corresponds to the primary key of the :py:class:`CIMInstanceName`;
             value contains the filtering value.
+        :param bool client_filtering: if True, client-side filtering will be performed,
+            otherwise the filtering will be done by a CIMOM. Default value is False.
         :param dictionary kwargs: supported keyword arguments (these are **deprecated**)
 
             * **Key** or **key** (*string*) -- filtering key, see above
@@ -216,20 +219,54 @@ class LMIBaseClient(object):
             kwargs.pop("Value")
         if filter_value:
             inst_filter[filter_key] = filter_value
-        query = "select * from %s" % class_name
-        if inst_filter:
-            more = False
-            query += " where"
-            for (filter_key, filter_value) in inst_filter.iteritems():
-                if more:
-                    query += " and"
-                quotes = isinstance(filter_value, basestring)
-                query += " %s =" % filter_key
-                query += " \"%s\"" % filter_value if quotes else " %s" % filter_value
-                more = True
-        (inst_list, _, errorstr) = self._exec_query(LMIBaseClient.QUERY_LANG_WQL, query, namespace)
-        if not inst_list:
-            return LMIReturnValue(rval=None, errorstr=errorstr)
+
+        if not client_filtering:
+            query = "select * from %s" % class_name
+            if inst_filter:
+                more = False
+                query += " where"
+                for (filter_key, filter_value) in inst_filter.iteritems():
+                    if more:
+                        query += " and"
+                    quotes = isinstance(filter_value, basestring)
+                    query += " %s =" % filter_key
+                    query += " \"%s\"" % filter_value if quotes else " %s" % filter_value
+                    more = True
+            (inst_list, _, errorstr) = self._exec_query(
+                LMIBaseClient.QUERY_LANG_WQL,
+                query,
+                namespace)
+            if inst_list is None:
+                return LMIReturnValue(rval=None, errorstr=errorstr)
+            return LMIReturnValue(rval=inst_list)
+
+        # Client-side filtering - this is not a pretty solution, but it needs
+        # to be present due to TOG-Pegasus, which does not raise an exception,
+        # if an error occurs while performing CQL/WQL query.
+        inst_list = None
+        try:
+            inst_list = self._cliconn.EnumerateInstances(
+                class_name,
+                LocalOnly=False,
+                DeepInheritance=True,
+                IncludeQualifiers=False)
+        except pywbem.cim_operations.CIMError, e:
+            lmi_raise_or_dump_exception(e)
+            return LMIReturnValue(rval=None, errorstr=e.args[1])
+        except pywbem.cim_http.AuthError, e:
+            lmi_raise_or_dump_exception(e)
+            return LMIReturnValue(rval=None, errorstr=e.args[0])
+
+        if inst_list and inst_filter:
+            inst_list_filtered = []
+            for inst in inst_list:
+                for (filter_key, filter_value) in inst_filter.iteritems():
+                    if not filter_key in inst.properties or \
+                            inst.properties[filter_key].value != filter_value:
+                        break
+                else:
+                    inst_list_filtered.append(inst)
+            inst_list = inst_list_filtered
         return LMIReturnValue(rval=inst_list)
 
     def _get_class_names(self, namespace=None, **kwargs):

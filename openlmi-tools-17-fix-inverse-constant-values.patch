diff --git a/cli/lmi/shell/LMIConstantValues.py b/cli/lmi/shell/LMIConstantValues.py
index f97b831..6420e8a 100644
--- a/cli/lmi/shell/LMIConstantValues.py
+++ b/cli/lmi/shell/LMIConstantValues.py
@@ -14,7 +14,9 @@
 # along with this program; if not, see <http://www.gnu.org/licenses/>.
 
 import abc
+import logging
 import sys
+import re
 
 from LMIBaseObject import LMIBaseObject
 from LMIUtil import lmi_cast_to_lmi
@@ -33,20 +35,33 @@ class LMIConstantValues(LMIBaseObject):
     __metaclass__ = abc.ABCMeta
 
     def __init__(self, cim_obj, cast_type):
-        # Keys can contain various undesirable characters, such as python
-        # operators, etc. So we drop them.
-        keys = map(lambda v: "".join(c for c in v if c.isalnum()),
-            cim_obj.qualifiers["Values"].value)
-        values = cim_obj.qualifiers["ValueMap"].value
+        logger = logging.getLogger(__name__)
+        items = zip(
+            cim_obj.qualifiers["Values"].value,
+            cim_obj.qualifiers["ValueMap"].value)
         self._value_map = {}
         self._value_map_inv = {}
         self._cast_type = cast_type
         # Fill two dictionaries for bidirectional access to constant values.
-        for i in range(0, len(keys)):
+        cnt = 1
+        for (key, value) in items:
             try:
-                key = keys[i]
-                val = lmi_cast_to_lmi(self._cast_type, values[i])
-                self._value_map[key] = val
+                # Cast constant value first. If we get ValueError, no key
+                # modifications are necessary.
+                val = lmi_cast_to_lmi(self._cast_type, value)
+
+                # Keys can contain various undesirable characters, such as
+                # python operators, etc. So we drop them.
+                mod_key = re.sub("\W", "", key)
+                if mod_key[0].isdigit():
+                    mod_key = "Key_" + mod_key
+                if mod_key in self._value_map:
+                    mod_key += str(cnt)
+                    cnt += 1
+                    logger.warn("Constant value mapped as: '%s' -> '%s'" % (key, mod_key))
+
+                self._value_map[mod_key] = val
+                # For inverse mapping, we use unmodified key.
                 self._value_map_inv[val] = key
             except ValueError, e:
                 # Can not cast such value as interval. Can be found in
